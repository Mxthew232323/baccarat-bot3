<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Baccarat Predictor with Accuracy & Patterns</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #fafafa; max-width: 600px; margin: auto; }
    h1 { font-size: 26px; text-align: center; }
    .btn { margin: 5px; padding: 12px 20px; font-size: 18px; border: none; cursor: pointer; border-radius: 8px; }
    .banker { background: #e74c3c; color: white; }
    .player { background: #3498db; color: white; }
    .tie { background: #f1c40f; color: black; }
    #history, #prediction, #stats, #accuracy, #patterns { margin-top: 20px; font-size: 18px; }
    .roadmap { display: flex; flex-wrap: wrap; margin-top: 10px; }
    .roadmap div { width: 30px; height: 30px; margin: 2px; text-align: center; line-height: 30px; border-radius: 4px; font-weight: bold; }
    .B { background: #e74c3c; color: white; }
    .P { background: #3498db; color: white; }
    .T { background: #f1c40f; color: black; }
  </style>
</head>
<body>
  <h1>Advanced Baccarat Predictor</h1>
  <div>
    <button class="btn banker" onclick="recordResult('B')">Banker</button>
    <button class="btn player" onclick="recordResult('P')">Player</button>
    <button class="btn tie" onclick="recordResult('T')">Tie</button>
  </div>

  <div id="history"></div>
  <div id="roadmap" class="roadmap"></div>
  <div id="prediction"></div>
  <div id="accuracy"></div>
  <div id="stats"></div>
  <div id="patterns"></div>

  <script>
    let history = JSON.parse(localStorage.getItem('baccarat_history')) || [];
    let correctPredictions = parseInt(localStorage.getItem('correct_predictions')) || 0;
    let totalPredictions = parseInt(localStorage.getItem('total_predictions')) || 0;

    function recordResult(result) {
      history.push(result);
      localStorage.setItem('baccarat_history', JSON.stringify(history));
      updatePredictionAccuracy();
      updateUI();
    }

    function updateUI() {
      document.getElementById('history').innerText = "History: " + history.join(', ');

      const roadmap = document.getElementById('roadmap');
      roadmap.innerHTML = '';
      history.forEach(r => {
        const cell = document.createElement('div');
        cell.className = r;
        cell.innerText = r;
        roadmap.appendChild(cell);
      });

      const prediction = predictNext();
      document.getElementById('prediction').innerText = "Prediction: " + prediction;

      const stats = calculateStats();
      document.getElementById('stats').innerText = `Player: ${stats.P}, Banker: ${stats.B}, Tie: ${stats.T}`;

      const accuracyPercent = totalPredictions ? ((correctPredictions / totalPredictions) * 100).toFixed(2) : "0.00";
      document.getElementById('accuracy').innerText = `Prediction Accuracy: ${accuracyPercent}% (${correctPredictions}/${totalPredictions})`;

      document.getElementById('patterns').innerText = "Common Patterns: " + findCommonPatterns().join(', ');
    }

    function updatePredictionAccuracy() {
      if(history.length < 2) return; // Need at least 2 to predict

      // Predict the next based on previous history (excluding last)
      const predicted = predictNextForIndex(history.length - 1);
      const actual = history[history.length - 1];

      totalPredictions++;
      if (predicted === actual) correctPredictions++;

      localStorage.setItem('correct_predictions', correctPredictions);
      localStorage.setItem('total_predictions', totalPredictions);
    }

    function predictNext() {
      // Predict for current length (to show next prediction)
      return predictNextForIndex(history.length);
    }

    function predictNextForIndex(index) {
      // We'll predict the next outcome given history up to index-1 (index is future position)
      if (index < 1) return randomChoice();

      const last = history[index - 1];
      let streak = 1;
      for (let i = index - 2; i >= 0; i--) {
        if (history[i] === last) streak++;
        else break;
      }

      if (streak >= 3) return last;

      // Pattern recognition for last 4 outcomes before index (if available)
      if (index >= 4) {
        const pattern4 = history.slice(index - 4, index).join('');
        if (pattern4 === 'BPBP') return 'P';
        if (pattern4 === 'PBPB') return 'B';
      }

      return weightedPrediction();
    }

    function weightedPrediction() {
      // Banker bias as known in Baccarat
      const weights = { B: 0.51, P: 0.49 };
      return Math.random() < weights.B ? 'B' : 'P';
    }

    function randomChoice() {
      return Math.random() > 0.5 ? 'B' : 'P';
    }

    function calculateStats() {
      const count = { B: 0, P: 0, T: 0 };
      history.forEach(h => { if (count[h] !== undefined) count[h]++; });
      return count;
    }

    function findCommonPatterns() {
      const patterns = {};
      for (let i = 0; i < history.length - 2; i++) {
        const pattern = history.slice(i, i + 3).join('');
        patterns[pattern] = (patterns[pattern] || 0) + 1;
      }
      const sorted = Object.entries(patterns).sort((a, b) => b[1] - a[1]);
      return sorted.slice(0, 3).map(p => `${p[0]} (${p[1]})`);
    }

    updateUI();
  </script>
</body>
</html>
